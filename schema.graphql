enum SaleType {
  FIXEDSALE
  AUCTIONSALE
  NONE
}
enum LoanStatus {
  PENDING
  ACTIVE
  CLOSED
  LIQUIDATED
  LOAN_REPAID
}
enum BidStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}
enum LockStatus {
  ACTIVE
  LIQUIDATED
  UNLOCKED
}
enum TransactionType {
  TRANSFER
  FIXED_SALE_LISTING
  FIXED_SALE_SOLD
  FIXED_SALE_CANCELLED
  FIXED_SALE_UPDATED
  AUCTION_SALE_LISTING
  AUCTION_SALE_CANCELLED
  AUCTION_BID_CREATED
  AUCTION_BID_ACCEPTED
  COLLECTION_OFFER_ACCEPTED
  TOKEN_OFFER_CREATED
  TOKEN_OFFER_UPDATED
  TOKEN_OFFER_ACCEPTED
  TOKEN_OFFER_DELETED
  LOAN_REQUEST_OPEN
  LOAN_REQUEST_CANCELLED
  LOAN_REQUEST_ACTIVE
  LOAN_REQUEST_BID_OPEN
  LOAN_REQUEST_BID_CANCELLED
  LOAN_REQUEST_BID_LOST
  LOAN_LIQUIDATED
  LOAN_REPAID
  TOKENS_LOCKED
}
enum CollectionStatus {
  VERIFIED
  UNVERIFIED
}

type supportedCollection @entity {
  " the ID is supportedcollection and collection address "
  id: ID!

  " Collection fee revenue collector "
  creator: Bytes!

  " The trading fee for the collection "
  royaltyFees: BigInt!

  " The collection images "
  metadata: CollectionMetadata

  " The collection address "
  collection: collection!

  " The collection status "
  status: CollectionStatus!
}

type CollectionMetadata @entity {
  " The ID is the ipfs hash "
  id: ID!

  " The collection banner image "
  bannerImage: String!

  " The collection description "
  description: String!

  " The collection placeholder Image "
  placeholderImage: String!

  " The collection small image "
  smallImage: String!

  " The collection twitter link "
  twitter: String

  " The collection discord link "
  discord: String

  " The collection telegram link "
  telegram: String

  " The collection website link "
  website: String
}

type saleInfo @entity {
  " The ID is the concatenation of kcc, collection address, and token ID "
  id: ID!

  " The collection address for the sale "
  collection: collection!

  " The token ID involved in the sale "
  token: token!

  " The price of the token "
  salePrice: BigInt

  " The state of the sale; fixedSale, auctionSale and none "
  state: SaleType!

  " The starting bid for the auction if sale is an auction "
  startingBid: BigInt

  " The highest bid and current for the auction "
  highestBid: BigInt

  " The highest bidder for the auction "
  highestBidder: account

  " The time the auction ends "
  validity: BigInt

  " The transactions for the sales "
  transactions: [transaction!] @derivedFrom(field: "saleInfo")

  " An array of bid entities "
  auctionBids: [auctionBid!]

  " timestamp of the last listing "
  timestamp: Int!
}

type auctionBid @entity {
  " The id is the collection address, token ID and its bidder "
  id: ID!

  " The bidder "
  bidder: account!

  " The bid value "
  bid: BigInt!
}

type collectionOffer @entity {
  " ID is the concatenation of collection address and the offer creator "
  id: ID!

  " The collection address for the offer "
  collection: collection!

  " The offer creator "
  creator: account!

  " The offer amount or value "
  amount: BigInt!

  " The total count of nfts the Offer creator is offering to buy "
  total: Int!

  " The validity period of the offer "
  validity: BigInt!
}

type collectionTokenOffer @entity {
  " ID is the concatenation of collection, creator address and tokenId "
  id: ID!

  " The collection address for the offer "
  collection: collection!

  " The offer creator "
  creator: account!

  " The token ID involved in the offer "
  token: token!

  " The offer amount/value "
  value: BigInt!

  " The validity period of the offer "
  validity: BigInt!
}

type contract @entity {
  id: ID!
  asERC721: collection
}

type accountStatistic @entity {
  " account address "
  id: Bytes!

  " The points earned by this account "
  points: Int!

  " The total volume of sales for this account "
  salesVolume: BigInt!

  " The total sales for this account "
  totalSales: Int!

  " total interest paid as a borrower "
  paidInterest: BigInt!

  " total interest earned as a lender "
  earnedInterest: BigInt!

  " total loans taken as a borrower "
  borrowCount: Int!

  " total loans funded as a lender "
  lendCount: Int!

  " total loans defaulted on as a borrower "
  defaultCount: Int!

  " withdrawable bids from failed bids "
  withdrawableBid: BigInt!

  " total revenue generated by the account "
  revenue: BigInt!

  " total borrowed "
  totalBorrowedAmount: BigInt!

  " total lent "
  totalLentAmount: BigInt!

  " account pointer "
  account: account!
}

type account @entity {
  " the wallet address "
  id: ID!

  " The NFTs owned by this account "
  tokens: [token!]! @derivedFrom(field: "owner")

  " The transfers originating from this account "
  transfersFrom: [transfer!] @derivedFrom(field: "senderAddress")

  " The transfers recevied by this account"
  transfersTo: [transfer!] @derivedFrom(field: "receiverAddress")

  " M:M relationship for Accounts and Collections "
  accountCollection: [accountCollection!] @derivedFrom(field: "account")

  " Tokens bidded by account"
  auctionBids: [saleInfo!] @derivedFrom(field: "highestBidder")

  " Collection offers made by account "
  collectionOffers: [collectionOffer!] @derivedFrom(field: "creator")

  " Token offer made for by account "
  tokenCollectionOffers: [collectionTokenOffer!] @derivedFrom(field: "creator")

  " locked nfts "
  lockedIds: [lockId!] @derivedFrom(field: "depositor")

  " loan contract bids "
  loanBids: [loanBid!] @derivedFrom(field: "bidder")

  " loanContract as a borrower "
  borrows: [loanContract!] @derivedFrom(field: "borrower")

  " loanContract as a lender "
  lends: [loanContract!] @derivedFrom(field: "lender")

  " account statistics "
  accountStatistic: accountStatistic @derivedFrom(field: "account")
}

type collection @entity {
  " The address of the collection "
  id: ID!

  " The name of the collection "
  name: String

  " The symbol for the collection "
  symbol: String

  " Total Supply of Tokens "
  totalSupply: BigInt

  " Total Value locked for offers "
  valueLocked: BigInt!

  " Mint Price "
  mintPrice: BigDecimal

  " Collection creator "
  creator: account

  " Tokens for the collection"
  tokens: [token!]! @derivedFrom(field: "collection")

  " Tokens in the collection for sale"
  saleInfos: [saleInfo!] @derivedFrom(field: "collection")

  " offers made for tokens in this collection "
  collectionOffers: [collectionOffer!] @derivedFrom(field: "collection")

  " Collection supports metadata "
  supportsMetadata: Boolean

  " Total sales "
  totalSales: Int!

  " Total volume "
  totalVolume: BigDecimal!

  " Top Sale ever "
  topSale: BigDecimal!

  " Floor price of collection "
  floorPrice: BigDecimal!

  " Listing prices of items in collection "
  listingPrices: [BigInt!]!

  " Hourly info about the collection "
  hourlyCollectionSnapshot: [hourlyCollectionSnapshot!]!
    @derivedFrom(field: "collection")

  " Daily info about the collection "
  dailyCollectionSnapshot: [dailyCollectionSnapshot!]!
    @derivedFrom(field: "collection")

  " Weekly info about the collection "
  weeklyCollectionSnapshot: [weeklyCollectionSnapshot!]!
    @derivedFrom(field: "collection")

  " M:M relationship for Accounts and Collections "
  accountCollection: [accountCollection!]! @derivedFrom(field: "collection")

  " Collection loan statistics "
  loanStatistic: collectionLoanStatistic @derivedFrom(field: "collection")
}

type collectionLoanStatistic @entity {
  " Collection address as id "
  id: Bytes!

  " Average loan size: division of all loans taken from this collection "
  averageLoanAmount: BigDecimal!

  " total loan amount taken in this collection "
  totalLoanVolume: BigDecimal!

  " total loans taken in this collection "
  totalLoanCount: Int!

  " largest single loan taken for the collection "
  largestLoan: BigDecimal!

  " total interest paid by borrowers "
  totalPaidInterest: BigInt!

  " the collection pointer for this statistics "
  collection: collection!
}

type token @entity {
  " kcc / Collection Addrress - Token Id "
  id: ID!

  " The collection address "
  collection: collection!

  " The token URI "
  tokenURI: String!

  " The token metadata "
  metadata: TokenMetadata

  " Used to track last fetched time for token metadata "
  updatedAtTimestamp: BigInt!

  " Token ID / identifier but as a string for fullTextSearch "
  tokenId: String!

  " The address that currently owns the token "
  owner: account

  " Transfers involving this token "
  transfers: [transfer!]! @derivedFrom(field: "token")

  " token saleInfo "
  saleInfo: saleInfo @derivedFrom(field: "token")

  " offers made for this token "
  tokenOffers: [collectionTokenOffer!] @derivedFrom(field: "token")
}

type TokenMetadata @entity {
  " metadata hash "
  id: ID!

  " The image of the NFT"
  image: String

  " The name of the NFT"
  name: String

  " The description of the NFT"
  description: String

  " The token attributes "
  attributes: [TokenAttribute!] @derivedFrom(field: "metadata")
}

type TokenAttribute @entity {
  " the metadata for token "
  id: ID!

  " the metadata for token "
  metadata: TokenMetadata!

  " The attribute trait type "
  traitType: String

  " The attribute value "
  value: String
}

type accountCollection @entity {
  " Account Id - Collection Id "
  id: ID!

  " Address of the account "
  account: account

  " Address of the NFT Collection "
  collection: collection

  " Count of NFT's owned in a collection by the Address"
  tokenCount: Int!
}

type transaction @entity {
  " the hash of the tx"
  id: ID!

  " Timestamp for block "
  timestamp: Int!

  " Block Number "
  blockNumber: Int!

  " Address who initiated the transaction "
  transactionFrom: Bytes!

  " Count of how many transfers were not matched to a sale "
  unmatchedTransferCount: Int!

  " Transfers that occured within the transaction "
  transfers: [transfer!]!

  " Sale events that occured within the transaction "
  sales: [sale!] @derivedFrom(field: "transaction")

  " Gas Spent "
  gasPrice: BigInt

  " transaction type to reference "
  txType: TransactionType

  " saleInfo reference if the transaction involved a listing "
  saleInfo: saleInfo
}

type transfer @entity {
  " Block Number and Event Id in which the transfers event occured"
  id: ID!

  " Transaction hash in which the transfer event occured"
  transaction: transaction!

  " The collection address "
  collection: collection!

  " The collection addrress - The token id "
  token: token!

  " The sender address "
  senderAddress: account

  " The receiver address "
  receiverAddress: account

  " Timestamp for block "
  timestamp: Int!

  " Block Number "
  blockNumber: Int!

  " The amount of KCS/WKCS paid"
  amount: BigDecimal!

  " matched sale event for the transfer "
  matchedSale: sale
}

type sale @entity {
  " Block Number and Event Id in which the sale event occured"
  id: ID!

  " tx that the sale occured in "
  transaction: transaction!

  " the amount of the sale "
  amount: BigDecimal!
}

type hourlyCollectionSnapshot @entity {
  " The collection address - The hour "
  id: ID!

  " Unix Hour (Timestamp / 3600 * 3600) "
  timestamp: Int

  " The collection address "
  collection: collection!

  " The hourly volume "
  hourlyVolume: BigDecimal!

  " Number of hourly transactions "
  hourlyTransactions: Int

  " Average sale amount for the day "
  hourlyAvgSale: BigDecimal!

  " Hourly top sales "
  topSale: BigDecimal!

  " Hourly bottom sales "
  bottomSale: BigDecimal!
}

type dailyCollectionSnapshot @entity {
  " The collection address - The day "
  id: ID!

  " Unix Day (Timestamp / 86400 * 86400) "
  timestamp: Int

  " The collection address "
  collection: collection!

  " The daily volume "
  dailyVolume: BigDecimal!

  " Number of daily transactions "
  dailyTransactions: Int

  " Average sale amount for the day "
  dailyAvgSale: BigDecimal!

  " Daily top sales "
  topSale: BigDecimal!

  " Daily bottom sales "
  bottomSale: BigDecimal!
}

type weeklyCollectionSnapshot @entity {
  " The collection address - The week "
  id: ID!

  " Unix Week (Timestamp / 604800 * 604800) "
  timestamp: Int

  " The collection address "
  collection: collection!

  " The monthly volume "
  weeklyVolume: BigDecimal!

  " Number of monthly transactions "
  weeklyTransactions: Int

  " Average sale amount for the day "
  weeklyAvgSale: BigDecimal!

  " Weekly top sales "
  topSale: BigDecimal!

  " Weekly bottom sales "
  bottomSale: BigDecimal!
}

type protocol @entity {
  " The protocol contract address "
  id: Bytes!

  " The protocol name "
  name: String!

  " The tokens locked by this protocol "
  lockedIds: [lockId!] @derivedFrom(field: "protocol")

  " The protocol fee "
  protocolFee: Int!

  " The security fee "
  securityFee: Int!

  " total borrows "
  totalLoanVolume: BigDecimal!

  " total loan count "
  totalLoanCount: Int!

  " interest paid by borrowers "
  totalPaidInterest: BigInt!

  " Average loan size: division of all loans taken from the protocol "
  averageLoanAmount: BigDecimal!

  " largest single loan taken in the protocol "
  largestLoan: BigDecimal!
}

type lockId @entity {
  " The lock id in string "
  id: ID!

  " The collection from which the tokens are locked "
  collection: collection!

  " An array of token entity of this collection that was locked "
  tokens: [token!]!

  " The address that locked the collections "
  depositor: account!

  " The protocol that locked the collections "
  protocol: protocol!

  " The timestamp of when the lock expires "
  expires: BigInt!

  " the contract it was opened for "
  contract: loanContract

  " the lock status "
  status: LockStatus!

  " Transaction hash in which the deposit event occured"
  transaction: transaction!
}

type loanContract @entity {
  " the loanContract id in bytes"
  id: ID!

  " The borrower address "
  borrower: account!

  " The lender address "
  lender: account!

  " The interest/apr to be paid "
  interest: Int!

  " The amount borrowed "
  amount: BigInt!

  " The loan expiry date. changes from days count to unix period when active "
  expiry: BigInt!

  " The start block of the loan "
  checkPointBlock: BigInt

  " state of the loan "
  status: LoanStatus!

  " the lockId of the tokens locked for the loan "
  lockId: lockId! @derivedFrom(field: "contract")

  " Bids made to this loan contract "
  bids: [loanBid!] @derivedFrom(field: "contract")

  " Transactions in which a loan contract event occured"
  transactions: [transaction!]

  " The loan contract collection statistics "
  collection: String!
}

type loanBid @entity {
  " the loanContract id - the bidder address "
  id: ID!

  " bidder address "
  bidder: account!

  " proposed interest "
  proposedInterest: Int!

  " Contract bidding for "
  contract: loanContract!

  " the bid status "
  status: BidStatus!
}

type _Schema_
  @fulltext(
    name: "search"
    language: en
    algorithm: rank
    include: [
      { entity: "token", fields: [{ name: "tokenId" }] }
      { entity: "account", fields: [{ name: "id" }] }
      {
        entity: "collection"
        fields: [{ name: "id", name: "name", name: "symbol" }]
      }
      { entity: "TokenMetadata", fields: [{ name: "name" }] }
      {
        entity: "TokenAttribute"
        fields: [{ name: "traitType", name: "value" }]
      }
    ]
  )
  @fulltext(
    name: "searchCollection"
    language: en
    algorithm: rank
    include: [
      { entity: "collection", fields: [{ name: "id" }] }
      { entity: "collection", fields: [{ name: "name" }] }
      { entity: "collection", fields: [{ name: "symbol" }] }
      { entity: "token", fields: [{ name: "tokenId" }] }
      { entity: "TokenMetadata", fields: [{ name: "name" }] }
      {
        entity: "TokenAttribute"
        fields: [{ name: "traitType", name: "value" }]
      }
    ]
  )
